use std::collections::{HashMap, HashSet};
use std::fmt::format;
use std::fs::File;
use std::io::Write;
use std::str::FromStr;
use super::function::{FunctionCode, FunctionCodeInfo};
use super::template::{TemplateCode, TemplateCodeInfo};
use super::types::*;
use crate::hir::very_concrete_program::VCP;
use crate::intermediate_representation::Instruction;
use crate::intermediate_representation::ir_interface::{
    ObtainMeta, AddressType, LocationRule, OperatorType, ConstraintBucket, InputInformation,
    StatusInput,
};
use crate::translating_traits::*;
use code_producers::c_elements::*;
use code_producers::coda_elements::*;
use code_producers::llvm_elements::array_switch::load_array_switch;
use code_producers::wasm_elements::*;
use code_producers::llvm_elements::*;
use code_producers::llvm_elements::fr::load_fr;
use code_producers::llvm_elements::functions::{create_function, FunctionLLVMIRProducer};
use code_producers::llvm_elements::stdlib::load_stdlib;
use code_producers::llvm_elements::types::{bigint_type, void_type};
use program_structure::program_archive::ProgramArchive;

pub struct CompilationFlags {
    pub main_inputs_log: bool,
    pub wat_flag: bool,
}

#[derive(Eq, PartialEq, Debug)]
pub struct Circuit {
    pub wasm_producer: WASMProducer,
    pub c_producer: CProducer,
    pub llvm_data: LLVMCircuitData,
    pub coda_data: CodaCircuitData,
    pub templates: Vec<TemplateCode>,
    pub functions: Vec<FunctionCode>,
}

impl Default for Circuit {
    fn default() -> Self {
        Circuit {
            c_producer: CProducer::default(),
            wasm_producer: WASMProducer::default(),
            llvm_data: LLVMCircuitData::default(),
            coda_data: CodaCircuitData::default(),
            templates: Vec::new(),
            functions: Vec::new(),
        }
    }
}

impl WriteLLVMIR for Circuit {
    fn produce_llvm_ir<'a, 'b>(
        &self,
        producer: &'b dyn LLVMIRProducer<'a>,
    ) -> Option<LLVMInstruction<'a>> {
        // Code for prelude

        // Code for standard library?
        load_fr(producer);
        load_stdlib(producer);

        // Generate all the switch functions
        let mut ranges = HashSet::new();
        let mappings = [
            &self.llvm_data.signal_index_mapping,
            &self.llvm_data.variable_index_mapping,
            &self.llvm_data.component_index_mapping,
        ];

        for mapping in mappings {
            for range_mapping in mapping.values() {
                for range in range_mapping.values() {
                    ranges.insert(range);
                }
            }
        }

        for range in ranges {
            load_array_switch(producer, range);
        }

        // Declare all the functions
        let mut funcs = HashMap::new();
        for f in &self.functions {
            let name = f.header.as_str();
            let arena_ty = bigint_type(producer).ptr_type(Default::default());
            let function = create_function(
                producer,
                f.get_source_file_id(),
                f.get_line(),
                f.name.as_str(),
                name,
                if f.returns.is_empty() || (f.returns.len() == 1 && *f.returns.get(0).unwrap() == 1)
                {
                    bigint_type(producer).fn_type(&[arena_ty.into()], false)
                } else {
                    void_type(producer).fn_type(&[arena_ty.into()], false)
                },
            );
            funcs.insert(name, function);
        }

        // Code for the functions
        for f in &self.functions {
            let function_producer = FunctionLLVMIRProducer::new(producer, funcs[f.header.as_str()]);
            Self::manage_debug_loc_from_curr(&function_producer, f.as_ref());
            f.produce_llvm_ir(&function_producer);
        }

        // Code for the templates
        for t in &self.templates {
            println!("Generating code for {}", t.header);
            // code.append(&mut t.produce_llvm_ir(producer));
            t.produce_llvm_ir(producer);
        }

        // Code for prologue

        None // No need to return at this level
    }
}

impl WriteWasm for Circuit {
    fn produce_wasm(&self, producer: &WASMProducer) -> Vec<String> {
        use code_producers::wasm_elements::wasm_code_generator::*;
        let mut code = vec![];
        code.push("(module".to_string());
        let mut code_aux = generate_imports_list();
        code.append(&mut code_aux);
        code_aux = generate_memory_def_list(&producer);
        code.append(&mut code_aux);

        code_aux = fr_types(&producer.prime_str);
        code.append(&mut code_aux);

        code_aux = generate_types_list();
        code.append(&mut code_aux);
        code_aux = generate_exports_list();
        code.append(&mut code_aux);

        code_aux = fr_code(&producer.prime_str);
        code.append(&mut code_aux);

        code_aux = desp_io_subcomponent_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_version_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_shared_rw_memory_start_generator(&producer);
        code.append(&mut code_aux);

        code_aux = read_shared_rw_memory_generator(&producer);
        code.append(&mut code_aux);

        code_aux = write_shared_rw_memory_generator(&producer);
        code.append(&mut code_aux);

        code_aux = reserve_stack_fr_function_generator();
        code.append(&mut code_aux);

        code_aux = init_generator(&producer);
        code.append(&mut code_aux);

        code_aux = set_input_signal_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_input_signal_size_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_raw_prime_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_field_num_len32_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_input_size_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_witness_size_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_witness_generator(&producer);
        code.append(&mut code_aux);

        code_aux = copy_32_in_shared_rw_memory_generator(&producer);
        code.append(&mut code_aux);

        code_aux = copy_fr_in_shared_rw_memory_generator(&producer);
        code.append(&mut code_aux);

        code_aux = get_message_char_generator(&producer);
        code.append(&mut code_aux);

        code_aux = build_buffer_message_generator(&producer);
        code.append(&mut code_aux);

        code_aux = build_log_message_generator(&producer);
        code.append(&mut code_aux);

        // Actual code from the program

        for f in &self.functions {
            code.append(&mut f.produce_wasm(producer));
        }

        for t in &self.templates {
            code.append(&mut t.produce_wasm(producer));
        }

        code_aux = generate_table_of_template_runs(&producer);
        code.append(&mut code_aux);

        code_aux = fr_data(&producer.prime_str);
        code.append(&mut code_aux);

        code_aux = generate_data_list(&producer);
        code.append(&mut code_aux);

        code.push(")".to_string());
        code
    }
    fn write_wasm<T: Write>(&self, writer: &mut T, producer: &WASMProducer) -> Result<(), ()> {
        use code_producers::wasm_elements::wasm_code_generator::*;

        writer.write_all("(module".as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        let mut code_aux = generate_imports_list();
        let mut code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = generate_memory_def_list(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = fr_types(&producer.prime_str);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = generate_types_list();
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = generate_exports_list();
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = fr_code(&producer.prime_str);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = desp_io_subcomponent_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_version_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_shared_rw_memory_start_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = read_shared_rw_memory_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = write_shared_rw_memory_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = reserve_stack_fr_function_generator();
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = init_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = set_input_signal_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_input_signal_size_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_raw_prime_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_field_num_len32_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_input_size_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_witness_size_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_witness_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = copy_32_in_shared_rw_memory_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = copy_fr_in_shared_rw_memory_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = get_message_char_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = build_buffer_message_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = build_log_message_generator(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        // Actual code from the program

        for f in &self.functions {
            f.write_wasm(writer, producer)?;
            writer.flush().map_err(|_| {})?;
        }

        for t in &self.templates {
            t.write_wasm(writer, producer)?;
            writer.flush().map_err(|_| {})?;
        }

        code_aux = generate_table_of_template_runs(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = fr_data(&producer.prime_str);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        code_aux = generate_data_list(&producer);
        code = merge_code(code_aux);
        writer.write_all(code.as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})?;

        writer.write_all(")".as_bytes()).map_err(|_| {})?;
        writer.flush().map_err(|_| {})
    }
}

impl WriteC for Circuit {
    fn produce_c(&self, producer: &CProducer, _parallel: Option<bool>) -> (Vec<String>, String) {
        use c_code_generator::*;
        let mut code = vec![];
        // Prologue
        code.push("#include <stdio.h>".to_string());
        code.push("#include <iostream>".to_string());
        code.push("#include <assert.h>".to_string());
        code.push("#include \"circom.hpp\"".to_string());
        code.push("#include \"calcwit.hpp\"".to_string());

        let mut template_headers = collect_template_headers(producer.get_template_instance_list());
        let function_headers: Vec<_> = self.functions.iter().map(|f| f.header.clone()).collect();
        let mut function_headers = collect_function_headers(function_headers);
        code.append(&mut template_headers);
        code.append(&mut function_headers);
        std::mem::drop(template_headers);
        std::mem::drop(function_headers);

        let (func_list_no_parallel, func_list_parallel) =
            generate_function_list(producer, producer.get_template_instance_list());

        code.push(format!(
            "Circom_TemplateFunction {}[{}] = {{ {} }};",
            function_table(),
            producer.get_number_of_template_instances(),
            func_list_no_parallel,
        ));

        code.push(format!(
            "Circom_TemplateFunction {}[{}] = {{ {} }};",
            function_table_parallel(),
            producer.get_number_of_template_instances(),
            func_list_parallel,
        ));

        code.push(format!(
            "uint get_main_input_signal_start() {{return {};}}\n",
            producer.get_number_of_main_outputs()
        ));

        code.push(format!(
            "uint get_main_input_signal_no() {{return {};}}\n",
            producer.get_number_of_main_inputs()
        ));
        code.push(format!(
            "uint get_total_signal_no() {{return {};}}\n",
            producer.get_total_number_of_signals()
        ));
        code.push(format!(
            "uint get_number_of_components() {{return {};}}\n",
            producer.get_number_of_components()
        ));
        code.push(format!("uint get_size_of_input_hashmap() {{return {};}}\n", SIZE_INPUT_HASHMAP));
        code.push(format!(
            "uint get_size_of_witness() {{return {};}}\n",
            producer.get_witness_to_signal_list().len()
        ));
        code.push(format!(
            "uint get_size_of_constants() {{return {};}}\n",
            producer.get_field_constant_list().len()
        ));
        code.push(format!(
            "uint get_size_of_io_map() {{return {};}}\n",
            producer.get_io_map().len()
        ));
        //code.append(&mut generate_message_list_def(producer, producer.get_message_list()));

        // Functions to release the memory
        let mut release_component_code = generate_function_release_memory_component();
        code.append(&mut release_component_code);

        // Actual code of the circuit
        code.push("// function declarations".to_string());
        for f in &self.functions {
            let (mut f_code, _) = f.produce_c(producer, None);
            code.append(&mut f_code);
        }
        code.push("// template declarations".to_string());
        for t in &self.templates {
            let (mut t_code, _) = t.produce_c(producer, None);
            code.append(&mut t_code);
        }

        // Epilogue
        let run_circuit = "void run".to_string();
        let run_circuit_args = vec![declare_circom_calc_wit()];
        let main_template_create = if producer.main_is_parallel {
            producer.main_header.clone() + "_create_parallel"
        } else {
            producer.main_header.clone() + "_create"
        };
        // We use 0 to indicate that the main component has no father
        let create_args = vec![
            "1".to_string(),
            "0".to_string(),
            CIRCOM_CALC_WIT.to_string(),
            "\"main\"".to_string(),
            "0".to_string(),
        ];
        let create_call = build_call(main_template_create, create_args);
        // let ctx_index = format!("{} = {};", declare_ctx_index(), create_call);
        let ctx_index = format!("{};", create_call);
        // let start_msg = "printf(\"Starting...\\n\");".to_string();
        // let end_msg = "printf(\"End\\n\");".to_string();

        let main_template_run = if producer.main_is_parallel {
            producer.main_header.clone() + "_run_parallel"
        } else {
            producer.main_header.clone() + "_run"
        };
        let mut run_args = vec![];
        // run_args.push(CTX_INDEX.to_string());
        run_args.push("0".to_string());
        run_args.push(CIRCOM_CALC_WIT.to_string());
        let run_call = format!("{};", build_call(main_template_run, run_args.clone()));

        let main_run_body = vec![ctx_index, run_call];
        code.push(build_callable(run_circuit, run_circuit_args, main_run_body));
        (code, "".to_string())
    }
}

impl Circuit {
    pub fn build(vcp: VCP, flags: CompilationFlags, version: &str) -> Self {
        use super::build::build_circuit;
        build_circuit(vcp, flags, version)
    }
    pub fn add_template_code(&mut self, template_info: TemplateCodeInfo) -> ID {
        let id = self.templates.len();
        let code = template_info.wrap();
        self.templates.push(code);
        id
    }
    pub fn add_function_code(&mut self, function_info: FunctionCodeInfo) -> ID {
        let id = self.functions.len();
        let code = function_info.wrap();
        self.functions.push(code);
        id
    }
    pub fn get_function(&self, id: ID) -> &FunctionCodeInfo {
        self.functions[id].as_ref()
    }
    pub fn get_template(&self, id: ID) -> &TemplateCodeInfo {
        self.templates[id].as_ref()
    }
    pub fn produce_ir_string_for_template(&self, id: ID) -> String {
        self.templates[id].to_string()
    }
    pub fn produce_ir_string_for_function(&self, id: ID) -> String {
        self.functions[id].to_string()
    }
    pub fn produce_c<W: Write>(
        &self,
        c_folder: &str,
        run_name: &str,
        c_circuit: &mut W,
        c_dat: &mut W,
    ) -> Result<(), ()> {
        use std::path::Path;
        let c_folder_path = Path::new(c_folder.clone()).to_path_buf();
        c_code_generator::generate_main_cpp_file(&c_folder_path).map_err(|_err| {})?;
        c_code_generator::generate_circom_hpp_file(&c_folder_path).map_err(|_err| {})?;
        c_code_generator::generate_fr_hpp_file(&c_folder_path, &self.c_producer.prime_str)
            .map_err(|_err| {})?;
        c_code_generator::generate_calcwit_hpp_file(&c_folder_path).map_err(|_err| {})?;
        c_code_generator::generate_fr_cpp_file(&c_folder_path, &self.c_producer.prime_str)
            .map_err(|_err| {})?;
        c_code_generator::generate_calcwit_cpp_file(&c_folder_path).map_err(|_err| {})?;
        c_code_generator::generate_fr_asm_file(&c_folder_path, &self.c_producer.prime_str)
            .map_err(|_err| {})?;
        c_code_generator::generate_make_file(&c_folder_path, run_name, &self.c_producer)
            .map_err(|_err| {})?;
        c_code_generator::generate_dat_file(c_dat, &self.c_producer).map_err(|_err| {})?;
        self.write_c(c_circuit, &self.c_producer)
    }
    pub fn produce_wasm<W: Write>(
        &self,
        js_folder: &str,
        _wasm_name: &str,
        writer: &mut W,
    ) -> Result<(), ()> {
        use std::path::Path;
        let js_folder_path = Path::new(js_folder.clone()).to_path_buf();
        wasm_code_generator::generate_generate_witness_js_file(&js_folder_path)
            .map_err(|_err| {})?;
        wasm_code_generator::generate_witness_calculator_js_file(&js_folder_path)
            .map_err(|_err| {})?;
        self.write_wasm(writer, &self.wasm_producer)
    }
    pub fn produce_llvm_ir(
        &mut self,
        program_archive: &ProgramArchive,
        out_path: &str,
    ) -> Result<(), ()> {
        self.write_llvm_ir(program_archive, out_path, &self.llvm_data)
    }
    pub fn produce_coda(
        &self,
        program_archive: &ProgramArchive,
        summary: &SummaryRoot,
        out_file: &mut File,
    ) -> Result<(), ()> {
        let str = self.print_coda(self, program_archive, summary);
        out_file
            .write_all(str.as_bytes())
            .map_err(|err| eprintln!("Error writing to the Coda file: {}", err))
    }
}

// -----------------------------------------------------------------------------
// BEGIN Coda
// -----------------------------------------------------------------------------

fn pretty_print_input_information(input_information: &InputInformation) -> String {
    match &input_information {
        InputInformation::NoInput => format!("NoInput"),
        InputInformation::Input { status } => match status {
            StatusInput::Last => format!("Last"),
            StatusInput::NoLast => format!("NoLast"),
            StatusInput::Unknown => format!("Unknown"),
        },
    }
}

fn pretty_print_address_type(address_type: &AddressType) -> String {
    match &address_type {
        AddressType::Variable => format!("Variable"),
        AddressType::Signal => format!("Signal"),
        AddressType::SubcmpSignal {
            cmp_address,
            uniform_parallel_value: _,
            is_output: _,
            input_information,
        } => format!(
            "SubcmpSignal({}, {})",
            pretty_print_instruction(&cmp_address),
            pretty_print_input_information(&input_information)
        ),
    }
}

fn pretty_print_location_rule(location_rule: &LocationRule) -> String {
    match &location_rule {
        LocationRule::Indexed { location, template_header } => {
            format!("Ix(loc={}, header={:?})", pretty_print_instruction(location), template_header)
        }
        LocationRule::Mapped { signal_code: _, indexes: _ } => panic!(),
    }
}

fn pretty_print_instruction(instruction: &Instruction) -> String {
    match instruction {
        Instruction::Value(value) => format!("Value({})", value.value),
        Instruction::Load(load) => format!(
            "Load(type={}, src={})",
            pretty_print_address_type(&load.address_type),
            pretty_print_location_rule(&load.src)
        ),
        Instruction::Store(store) => format!(
            "Store(dest_type={}, dest={}, src={})",
            pretty_print_address_type(&store.dest_address_type),
            pretty_print_location_rule(&store.dest),
            pretty_print_instruction(&store.src)
        ),
        Instruction::Compute(compute) => format!(
            "Compute(op={}, arg0={}, arg1={})",
            compute.op.to_string(),
            pretty_print_instruction(&compute.stack[0]),
            pretty_print_instruction(&compute.stack[1])
        ),
        Instruction::Branch(branch) => format!(
            "Branch(cond={}, then={}, else={})",
            pretty_print_instruction(branch.cond.as_ref()),
            pretty_print_instructions(&branch.if_branch),
            pretty_print_instructions(&branch.else_branch)
        ),
        Instruction::CreateCmp(create_cmp) => format!(
            "CreateCmp(template_id={:?}, cmp_unique_id={:?}, symbol={:?}, sub_cmp_id={:?}, name_subcomponent={:?}, number_of_cmp={:?})",
            create_cmp.template_id,
            create_cmp.cmp_unique_id,
            create_cmp.symbol,
            pretty_print_instruction(create_cmp.sub_cmp_id.as_ref()),
            create_cmp.name_subcomponent,
            create_cmp.number_of_cmp
        ),
        Instruction::Constraint(constraint) => match &constraint {
            ConstraintBucket::Substitution(sub) => {
                format!("Sub({})", pretty_print_instruction(sub.as_ref()))
            }
            ConstraintBucket::Equality(eq) => {
                format!("Eq({})", pretty_print_instruction(eq.as_ref()))
            }
        },
        Instruction::Block(block) => format!("{{\n{}}}", pretty_print_instructions(&block.body).split("\n").map(|s| format!("  {}", s)).collect::<Vec<String>>().join("\n")),

        Instruction::Call(_) => todo!(),

        Instruction::Return(_) => panic!(),
        Instruction::Assert(_) => panic!(),
        Instruction::Log(_) => panic!(),
        Instruction::Loop(_) => panic!(),
        Instruction::Nop(_) => panic!(),
    }
}

fn pretty_print_instructions(instructions: &Vec<Box<Instruction>>) -> String {
    let mut str = String::new();
    for instruction in instructions {
        str.push_str(&format!("{}\n", pretty_print_instruction(instruction.as_ref())));
    }
    str
}

impl CompileCoda for Circuit {
    fn compile_coda(
        &self,
        circuit: &Circuit,
        program_archive: &ProgramArchive,
        summary: &SummaryRoot,
    ) -> code_producers::coda_elements::CodaProgram {
        let mut coda_program = CodaProgram::default();

        for template in &self.templates {
            // println!("template.name: {:?}", template.name);
            // println!(" - template.number_of_inputs: {:?}", template.number_of_inputs);
            // println!(" - template.number_of_intermediates: {:?}", template.number_of_intermediates);
            // println!(" - template.number_of_outputs: {:?}", template.number_of_outputs);
            // println!(" - template.number_of_components: {:?}", template.number_of_components);
            // println!(" - body:");

            // HENRY: can I not just use template.id as the index in summary.components? I'm guessing it couldn't be that easy... right?
            let template_summary =
                summary.components.iter().find(|t| t.name == template.name).unwrap();

            let name = template.name.clone();

            let mut inputs: Vec<CodaVar> = Vec::new();
            let mut intermediates: Vec<CodaVar> = Vec::new();
            let mut outputs: Vec<CodaVar> = Vec::new();

            for signal in &template_summary.signals {
                match CodaVisibility::from_str(&signal.visibility).unwrap() {
                    CodaVisibility::Input => inputs.push(CodaVar::make_signal(signal.name.clone())),
                    CodaVisibility::Output => {
                        outputs.push(CodaVar::make_signal(signal.name.clone()))
                    }
                    CodaVisibility::Intermediate => {
                        intermediates.push(CodaVar::make_signal(signal.name.clone()))
                    }
                }
            }

            if true {
                let mut template_string = String::new();
                template_string.push_str(&format!("name: {}\n", template.name));
                template_string
                    .push_str(&format!("number_of_inputs: {}\n", template.number_of_inputs));
                template_string.push_str(&format!(
                    "number_of_intermediates: {}\n",
                    template.number_of_intermediates
                ));
                template_string
                    .push_str(&format!("number_of_outputs: {}\n", template.number_of_outputs));
                template_string.push_str(&format!(
                    "number_of_components: {}\n",
                    template.number_of_components
                ));
                for signal in &template_summary.signals {
                    template_string
                        .push_str(&format!("signal {} {}\n", signal.visibility, signal.name));
                }
                template_string.push_str(&pretty_print_instructions(&template.body));
                println!(
                    "\n==================== BEGIN template ====================\n{}================ END template ====================",
                    template_string
                );
            }

            let body = compile_coda_stmt(
                circuit,
                program_archive,
                summary,
                template,
                &template_summary,
                HashMap::new(),
                &template.body,
                0,
            );

            let coda_template = CodaTemplate { name, inputs, intermediates, outputs, body };

            coda_program.templates.push(coda_template);
        }

        println!(
            "BEGIN Debug Circom Circuit\n\n{}\n\nEND Debug Circom Circuit",
            coda_program.print()
        );

        coda_program
    }
}

fn compile_coda_stmt(
    circuit: &Circuit,
    program_archive: &ProgramArchive,
    summary: &SummaryRoot,
    template: &TemplateCodeInfo,
    template_summary: &TemplateSummary,
    coda_component_infos: HashMap<usize, CodaComponentInfo>,
    instructions: &Vec<Box<Instruction>>,
    instruction_i: usize,
) -> CodaExpr {
    // end of instructions
    if instruction_i >= instructions.len() {
        println!("compile_coda_stmt: DONE");

        // tuple of all the outputs
        // let mut outs: Vec<Box<CodaExpr>> = Vec::new();

        let outs: Vec<CodaVar> = template_summary
            .signals
            .iter()
            .filter_map(|signal| {
                if signal.visibility == "output" {
                    Some(CodaVar::make_signal(signal.name.clone()))
                } else {
                    None
                }
            })
            .collect();

        CodaExpr::Tuple(outs.iter().map(|x| Box::new(CodaExpr::Var(x.clone()))).collect())
    } else {
        let instruction = instructions[instruction_i].clone();
        println!("compile_coda_stmt: {}", pretty_print_instruction(instruction.as_ref()));

        match instruction.as_ref() {
            Instruction::Constraint(constraint) => match &constraint {
                ConstraintBucket::Substitution(next_instruction) => {
                    let mut new_instructions = instructions.clone();
                    new_instructions.insert(instruction_i + 1, next_instruction.clone());
                    compile_coda_stmt(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        coda_component_infos,
                        &new_instructions,
                        instruction_i + 1,
                    )
                }
                ConstraintBucket::Equality(next_instruction) => {
                    let mut new_instructions = instructions.clone();
                    new_instructions.insert(instruction_i + 1, next_instruction.clone());
                    compile_coda_stmt(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        coda_component_infos,
                        &new_instructions,
                        instruction_i + 1,
                    )
                }
            },
            Instruction::Block(block) => {
                let next_instructions: Vec<Box<Instruction>> = [
                    instructions[0..instruction_i + 1]
                        .iter()
                        .cloned()
                        .collect::<Vec<Box<Instruction>>>(),
                    block.body.clone(),
                    instructions[instruction_i + 1..instructions.len()]
                        .iter()
                        .cloned()
                        .collect::<Vec<Box<Instruction>>>(),
                ]
                .concat();

                compile_coda_stmt(
                    circuit,
                    program_archive,
                    summary,
                    template,
                    &template_summary,
                    coda_component_infos,
                    &next_instructions,
                    instruction_i + 1,
                )
            }
            Instruction::Store(store) => {
                let mut opt_coda_component_info = None;

                let name = match &store.dest {
                    // In a `Store(store)` where `store.dest == Indexed { location }`, where `store.dest == SubcmpSignal { cmp_address }`, what does `cmp_address` correspond to? Is it the component's index in
                    LocationRule::Indexed { location, template_header } => {
                        match &store.dest_address_type {
                            // AddressType::Variable => todo!("Store Variable: {:?}", store),
                            AddressType::Variable => {
                                let var_i = from_instruction_to_value(location);
                                CodaVar::make_variable(var_i)
                            }
                            AddressType::Signal => {
                                let signal_i = from_instruction_to_value(location);

                                for signal in &template_summary.signals {
                                    println!("signal: {:?}", signal);
                                }

                                let signal = template_summary
                                    .signals
                                    .iter()
                                    .find(|signal| signal.idx == signal_i)
                                    .unwrap();
                                CodaVar::make_signal(signal.name.clone())
                            }
                            AddressType::SubcmpSignal {
                                cmp_address,
                                uniform_parallel_value: _,
                                is_output: _,
                                input_information,
                            } => {
                                let signal_i = from_instruction_to_value(location);
                                let cmp_i = from_instruction_to_value(cmp_address);
                                let cmp = &summary.components[cmp_i];
                                let signal = cmp
                                    .signals
                                    .iter()
                                    .find(|signal| signal.idx == signal_i)
                                    .unwrap();

                                match input_information {
                                    InputInformation::NoInput => (),
                                    InputInformation::Input { status } => match status {
                                        StatusInput::Last => {
                                            println!(" - template_header: {:?}", template_header);
                                            println!(" - cmp_i: {:?}", cmp_i);
                                            for info in &coda_component_infos {
                                                println!("info: {:?}", info);
                                            }
                                            let coda_component_info =
                                                coda_component_infos.get(&cmp_i).unwrap();
                                            opt_coda_component_info = Some(coda_component_info);
                                        }
                                        StatusInput::NoLast => (),
                                        StatusInput::Unknown => (),
                                    },
                                }

                                CodaVar::make_subcomponent_signal(
                                    cmp.name.clone(),
                                    signal.name.clone(),
                                )
                            }
                        }
                    }
                    LocationRule::Mapped { signal_code: _, indexes: _ } => panic!(),
                };

                // TODO:HENRY: check if this assignment was of the final input
                // to a subcomponent. if so, then need to define the
                // subcomponent as well

                let mut e = CodaExpr::Let(
                    name,
                    Box::new(compile_coda_expr(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        store.src.clone(),
                    )),
                    Box::new(compile_coda_stmt(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        coda_component_infos.clone(),
                        instructions,
                        instruction_i + 1,
                    )),
                );

                match opt_coda_component_info {
                    Some(coda_component_info) => {
                        // let coda_cmp_info = coda_component_infos.iter().find(|info| info.)
                        // let template_name = todo!();
                        // let component_name = todo!();
                        // let inputs = todo!();
                        // let outputs = todo!();
                        e = CodaExpr::Inst(coda_component_info.clone(), Box::new(e))
                    }
                    None => (),
                }

                e
            }
            Instruction::Branch(branch) => {
                let mut then_instructions = instructions.clone();
                then_instructions
                    .splice(instruction_i..instruction_i, branch.if_branch.iter().cloned());

                let mut else_instructions = instructions.clone();
                else_instructions
                    .splice(instruction_i..instruction_i, branch.else_branch.iter().cloned());

                CodaExpr::Branch {
                    condition: Box::new(compile_coda_expr(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        branch.cond.clone(),
                    )),
                    then_: Box::new(compile_coda_stmt(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        coda_component_infos.clone(),
                        &then_instructions,
                        instruction_i + 1,
                    )),
                    else_: Box::new(compile_coda_stmt(
                        circuit,
                        program_archive,
                        summary,
                        template,
                        &template_summary,
                        coda_component_infos.clone(),
                        &else_instructions,
                        instruction_i + 1,
                    )),
                }
            }
            Instruction::CreateCmp(create_cmp) => {
                /*
                    create_cmp.template_id: usize
                    create_cmp.cmp_unique_id: usize
                    create_cmp.sub_cmp_id: InstructionPointer
                    create_cmp.name_subcomponent: String
                    create_cmp.number_of_cmp: usize
                */

                let sub_cmp_id = from_instruction_to_value(&create_cmp.sub_cmp_id);
                let sub_template_id = create_cmp.template_id;
                let sub_template_summary = &summary.components[sub_template_id];
                let sub_template_data = &program_archive.templates[&sub_template_summary.name];
                let sub_template_name = &sub_template_summary.name;
                let sub_template_name_alt = sub_template_data.get_name();
                let sub_component_name = &create_cmp.name_subcomponent;

                println!(
                    "compile_coda_stmt: CreateCmp({:?}: {:?})",
                    sub_component_name, sub_template_name
                );

                // HENRY: this should hold if I'm understanding how subcomponent
                // data is stored
                assert!(sub_template_name == sub_template_name_alt);

                if true {
                    println!("create component:");
                    println!(" - template_id: {:?}", sub_template_id);
                    println!(" - template_name: {:?}", sub_template_name);
                    println!(" - component_name: {:?}", sub_component_name);
                    println!(" - name_subcomponent: {:?}", create_cmp.name_subcomponent);
                    println!(
                        " - sub_template_summary.logic_fn_name: {:?}",
                        sub_template_summary.logic_fn_name
                    );
                }

                let inputs: Vec<CodaVar> = template_summary
                    .signals
                    .iter()
                    .filter_map(|signal| {
                        if signal.visibility == "input" {
                            Some(CodaVar::make_signal(signal.name.clone()))
                        } else {
                            None
                        }
                    })
                    .collect();
                let outputs: Vec<CodaVar> = template_summary
                    .signals
                    .iter()
                    .filter_map(|signal| {
                        if signal.visibility == "output" {
                            Some(CodaVar::make_signal(signal.name.clone()))
                        } else {
                            None
                        }
                    })
                    .collect();

                let mut new_coda_component_infos = coda_component_infos.clone();

                new_coda_component_infos.insert(
                    sub_cmp_id,
                    CodaComponentInfo {
                        template_id: sub_template_id,
                        template_name: sub_template_name.clone(),
                        component_name: sub_component_name.to_string(),
                        header_name: "TODO".to_string(),
                        inputs,
                        outputs,
                    },
                );

                compile_coda_stmt(
                    circuit,
                    program_archive,
                    summary,
                    template,
                    &template_summary,
                    new_coda_component_infos,
                    instructions,
                    instruction_i + 1,
                )
            }

            Instruction::Load(_) => panic!("This case should not appear as a statement."),
            Instruction::Value(_) => panic!("This case should not appear as a statement."),
            Instruction::Compute(_) => panic!("This case should not appear as a statement."),
            Instruction::Call(_) => panic!("This case should not appear as a statement."),

            Instruction::Return(_) => panic!("This case is not handled by Circom->Coda"),
            Instruction::Assert(_) => panic!("This case is not handled by Circom->Coda"),
            Instruction::Log(_) => panic!("This case is not handled by Circom->Coda"),
            Instruction::Loop(_) => panic!("This case is not handled by Circom->Coda"),

            Instruction::Nop(_) => todo!(), // compile_coda_stmt(circuit, program_archive, summary, template, next_instructions),
        }
    }
}

fn compile_coda_expr(
    circuit: &Circuit,
    program_archive: &ProgramArchive,
    summary: &SummaryRoot,
    template: &TemplateCodeInfo,
    template_summary: &TemplateSummary,
    instruction: Box<Instruction>,
) -> CodaExpr {
    match instruction.as_ref() {
        Instruction::Value(value) => {
            let x = if value.value < circuit.coda_data.field_tracking.len() {
                circuit.coda_data.field_tracking[value.value].clone()
            } else {
                format!("BAD_VALUE_INDEX({})", value.value)
            };

            CodaExpr::Val(CodaVal::new(x))
        }

        Instruction::Load(load) => match &load.address_type {
            AddressType::Variable => panic!(),
            AddressType::Signal => match &load.src {
                LocationRule::Indexed { location, template_header: _ } => {
                    let signal_i = from_instruction_to_value(location);
                    let signal = template_summary
                        .signals
                        .iter()
                        .find(|signal| signal.idx == signal_i)
                        .unwrap();
                    CodaExpr::Var(CodaVar::make_signal(signal.name.clone()))
                }
                LocationRule::Mapped { signal_code: _, indexes: _ } => panic!(),
            },
            AddressType::SubcmpSignal {
                cmp_address,
                uniform_parallel_value: _,
                is_output: _,
                input_information: _,
            } => match &load.src {
                LocationRule::Indexed { location, template_header: _ } => {
                    let cmp_i = from_instruction_to_value(cmp_address);
                    let cmp = &summary.components[cmp_i];
                    let signal_i = from_instruction_to_value(location);
                    let signal = cmp.signals.iter().find(|signal| signal.idx == signal_i).unwrap();
                    CodaExpr::Var(CodaVar::make_subcomponent_signal(
                        cmp.name.clone(),
                        signal.name.clone(),
                    ))
                }
                LocationRule::Mapped { signal_code, indexes } => panic!(),
            },
        },

        Instruction::Compute(compute) => {
            assert!(compute.stack.len() == 2);
            let coda_op = compile_coda_op(compute.op);
            let coda_expr1 = compile_coda_expr(
                circuit,
                program_archive,
                summary,
                template,
                &template_summary,
                compute.stack[0].clone(),
            );
            let coda_expr2 = compile_coda_expr(
                circuit,
                program_archive,
                summary,
                template,
                &template_summary,
                compute.stack[1].clone(),
            );
            CodaExpr::Op(coda_op, Box::new(coda_expr1), Box::new(coda_expr2))
        }

        Instruction::Branch(branch) => {
            assert!(branch.if_branch.len() == 1);
            let if_branch = branch.if_branch[0].clone();

            assert!(branch.if_branch.len() == 1);
            let else_branch = branch.else_branch[0].clone();

            CodaExpr::Branch {
                condition: Box::new(compile_coda_expr(
                    circuit,
                    program_archive,
                    summary,
                    template,
                    &template_summary,
                    branch.cond.clone(),
                )),
                then_: Box::new(compile_coda_expr(
                    circuit,
                    program_archive,
                    summary,
                    template,
                    &template_summary,
                    if_branch,
                )),
                else_: Box::new(compile_coda_expr(
                    circuit,
                    program_archive,
                    summary,
                    template,
                    &template_summary,
                    else_branch,
                )),
            }
        }

        Instruction::Block(block) => {
            assert!(block.body.len() == 1);
            let body = block.body[0].clone();
            compile_coda_expr(circuit, program_archive, summary, template, &template_summary, body)
        }

        // panic!("This case cannot appear as an expression.")
        Instruction::Constraint(_) => panic!("This case cannot appear as an expression."),
        Instruction::CreateCmp(_) => panic!("This case cannot appear as an expression."),
        Instruction::Store(_) => panic!("This case cannot appear as an expression."),

        // panic!("This case is not handled by Circom->Coda")
        Instruction::Loop(_) => panic!("This case is not handled by Circom->Coda"),
        Instruction::Call(_) => panic!("This case is not handled by Circom->Coda"),
        Instruction::Return(_) => panic!("This case is not handled by Circom->Coda"),
        Instruction::Assert(_) => panic!("This case is not handled by Circom->Coda"),
        Instruction::Log(_) => panic!("This case is not handled by Circom->Coda"),
        Instruction::Nop(_) => panic!("This case is not handled by Circom->Coda"),
    }
}

fn compile_coda_op(op: OperatorType) -> CodaOp {
    match op {
        OperatorType::Mul => CodaOp::Mul,
        OperatorType::Div => CodaOp::Div,
        OperatorType::Add => CodaOp::Add,
        OperatorType::Sub => CodaOp::Sub,
        OperatorType::Pow => CodaOp::Pow,
        OperatorType::Mod => CodaOp::Mod,
        OperatorType::IntDiv => todo!(),
        OperatorType::ShiftL => todo!(),
        OperatorType::ShiftR => todo!(),
        OperatorType::LesserEq => todo!(),
        OperatorType::GreaterEq => todo!(),
        OperatorType::Lesser => todo!(),
        OperatorType::Greater => todo!(),
        OperatorType::Eq(_) => todo!(),
        OperatorType::NotEq => todo!(),
        OperatorType::BoolOr => todo!(),
        OperatorType::BoolAnd => todo!(),
        OperatorType::BitOr => todo!(),
        OperatorType::BitAnd => todo!(),
        OperatorType::BitXor => todo!(),
        OperatorType::PrefixSub => todo!(),
        OperatorType::BoolNot => todo!(),
        OperatorType::Complement => todo!(),
        OperatorType::ToAddress => todo!(),
        OperatorType::MulAddress => todo!(),
        OperatorType::AddAddress => todo!(),
    }
}

fn from_instruction_to_value(instruction: &Box<Instruction>) -> usize {
    match instruction.as_ref() {
        Instruction::Value(value) => value.value,
        _ => panic!("Expected `{:?}` to be of the form `Value(_)`", instruction),
    }
}

// -----------------------------------------------------------------------------
// END Coda
// -----------------------------------------------------------------------------
